#include<bits/stdc++.h>
using namespace std;
#define nl                      "\n"
#define ff                      first
#define ss                      second
#define ll                      long long int
#define pb                      push_back
#define cceil(a, b)             (((a) + (b) - 1) / (b))
#define sqr(x)                  ((x)*(x))
#define pi                      acos(-1)
#define gcd(x,y)                __gcd(x,y)
#define lcm(x,y)                ((x * y) / gcd(x,y))
#define all(x)                  (x).begin(), (x).end()
#define sorta(x)                sort(all(x))
#define sortd(x)                sort(all(x), greater<int>())
#define max3(x,y,z)             max({x, y, z})
#define max4(x,y,z,zz)          max({x, y, z, zz})
#define maxm(x)                 *max_element(all(x))
#define min3(x,y,z)             min({x, y, z})
#define min4(x,y,z,zz)          min({x, y, z, zz})
#define minm(x)                 *min_element(all(x))
#define valid(nx,ny,row,col)    (nx >= 1 && nx <= row && ny >= 1 && ny <= col)
#define yes                     cout << "Yes" << nl
#define yess                    cout << "YES" << nl
#define no                      cout << "No" << nl
#define noo                     cout << "NO" << nl
#define mone                    cout << -1 << nl
#define alice                   cout << "Alice" << nl
#define bob                     cout << "Bob" << nl
#define multiple_test           int test; cin >> test; while(test--) { solve(); }
#define single_test             solve();
#define space                   >> ' ' >>

const int MOD = 1e9 + 7;

using pairi     = pair<int, int>;
using pairl     = pair<ll, ll>;
using mapi      = map<int, int>;
using vi        = vector<int>;
using vl        = vector<ll>;
using vvi       = vector<vi>;
using vvl       = vector<vl>;
using vpi       = vector<pairi>;
using vpl       = vector<pairl>;
using si        = set<int>;
using qi        = queue<int>;
using pqia      = priority_queue<int>;
using pqid      = priority_queue<int, vector<int>, greater<int>>;

/*------------------------------Graph Moves----------------------------*/
// const int fx[]={+1,-1,+0,+0};             // 4 directions
// const int fy[]={+0,+0,+1,-1};             // 4 directions
// const int fx[]={+0,+0,+1,-1,-1,+1,-1,+1}; // Kings Move
// const int fy[]={-1,+1,+0,+0,+1,+1,-1,-1}; // Kings Move
// const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move
// const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move
/*---------------------------------------------------------------------*/
vpi v;
struct FenwickTree {
    vector<ll> bit;
    int MaxVal;
    FenwickTree(int n) {
        MaxVal = n;
        bit.assign(n, 0);
    }
    ll prefix_sum(int r) {
        ll ret = 0;
        while ( r >= 0 )
        {
            ret += bit[r];
            r = (r & (r + 1)) - 1;
        }
        return ret;
    }
    ll range_sum(int l, int r) {
        return prefix_sum(r) - prefix_sum(l - 1);
    }
    void single_update(int idx, ll val) {
        while (idx < MaxVal) {
            bit[idx] += val;
            idx |= (idx + 1);
        }
    }
    void range_update(int l, int r, ll val)
    {
        single_update(l, val);
        single_update(r + 1, -val);
    }
};
int lowerbound(int x)
{
    int l = 0, r = v.size() - 1, ind;
    while(l <= r)
    {
        int mid = l + (r - l) / 2;
        if(v[mid].first >= x)
        {
            ind = mid;
            r = mid - 1;
        }
        else
            l = mid + 1;
    }
    return v[ind].second;
}
void solve()
{
    int n, q;
    cin>>n>>q;
    vector<int> a(n);
    vector<pair<char, pair<int, int>>> qy;
    for(int i = 0; i < n; i++)
    {
        cin>>a[i];
        v.pb({a[i], 0});
    }
    char c;
    int b, d;
    int qq = q;
    while(q--)
    {
        cin>>c>>b>>d;
        if(c == '!')
        {
            b--;
            v.pb({d, 0});
            qy.pb({c, {b, d}});
            continue;
        }
        v.pb({b, 0});
        v.pb({d, 0});
        qy.pb({c, {b, d}});
    }
    sorta(v);
    int ind = 0;
    for(int i = 0; i < v.size(); i++)
    {
        if(i and v[i].first != v[i-1].first)
            ind++;
        v[i].second = ind;
    }
    FenwickTree bit(ind + 1);
    for(int i = 0; i < n; i++)
    {
        ind = lowerbound(a[i]);
        bit.single_update(ind, 1);
    }
    for(int i = 0; i < qq; i++)
    {
        c = qy[i].first;
        b = qy[i].second.first;
        d = qy[i].second.second;
        if(c == '!')
        {
            bit.single_update(lowerbound(a[b]), -1);
            a[b] = d;
            bit.single_update(lowerbound(d), 1);
            continue;
        }
        cout<<bit.range_sum(lowerbound(b), lowerbound(d))<<endl;
    }
}
int main()
{
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    //multiple_test
    single_test
    return 0;
}
